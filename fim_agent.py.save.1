import hashlib
from pathlib import Path
import json # JSON data (baseline) save/load করার জন্য
import sys  # কমান্ড লাইন আর্গুমেন্ট হ্যান্ডেল করার জন্য
import time


# --- Configuration ---
# NOTE: We use relative path here so it works on both Windows and Linux when testing.
TARGET_DIR = Path("target_files") 

def calculate_sha256(filepath: Path) -> str:
    """Calculates the SHA256 hash of a file."""
    
    # Check if the file exists and is actually a file
    if not filepath.is_file():
        # Return an empty string or raise an error for non-files
        return ""
        
    hasher = hashlib.sha256()
    
    # Open the file in binary read mode ('rb')
    try:
        with open(filepath, 'rb') as file:
            # Read the file in chunks (4KB) to handle large files efficiently
            while chunk := file.read(4096):
                hasher.update(chunk)
        return hasher.hexdigest()
    except Exception as e:
        print(f"Error reading file {filepath}: {e}")
        return "ERROR"

# --- Configuration ---
BASELINE_FILENAME = "baseline.json"
# TARGET_DIR কনফিগারেশনটি আগের মতোই থাকবে

def create_baseline(target_dir: Path):
    """
    Creates and saves the SHA256 baseline for all files in the target directory.
    """
    if not target_dir.is_dir():
        print(f"ERROR: Target directory '{target_dir}' does not exist.")
        return
        
    print(f"[*] Starting baseline creation for: {target_dir}")
    current_baseline = {}
    
    for filepath in target_dir.rglob('*'):
        if filepath.is_file():
            # ফাইলের সাপেক্ষ পথ (relative path) ব্যবহার করা
            relative_path = str(filepath.relative_to(target_dir))
            
            # হ্যাশ গণনা
            file_hash = calculate_sha256(filepath)
            
            current_baseline[relative_path] = file_hash
            print(f"    [+] Hashed {relative_path}")

    # JSON ফাইল হিসেবে বেসলাইন সেভ করা
    try:
        with open(BASELINE_FILENAME, 'w') as f:
            json.dump(current_baseline, f, indent=4)
        print(f"\n[SUCCESS] Baseline saved to {BASELINE_FILENAME}")
    except Exception as e:
        print(f"\n[ERROR] Could not save baseline file: {e}")

def load_baseline() -> dict:
    """
    Loads the baseline from the saved JSON file.
    """
    if not Path(BASELINE_FILENAME).exists():
        print(f"ERROR: Baseline file '{BASELINE_FILENAME}' not found. Please create a baseline first.")
        return {}
        
    try:
        with open(BASELINE_FILENAME, 'r') as f:
            return json.load(f)
    except json.JSONDecodeError:
        print(f"ERROR: Baseline file '{BASELINE_FILENAME}' is corrupted.")
        return {}


def check_integrity(target_dir: Path, baseline: dict):
    """
    Compares current file hashes against the loaded baseline to detect breaches.
    """
    
    current_hashes = {}
    incidents = {
        "modified": [],
        "added": [],
        "deleted": []
    }
    
    print("\n[*] Starting Integrity Check...")
    
    # 1. বর্তমান হ্যাশ তৈরি (Find Modification and Addition)
    for filepath in target_dir.rglob('*'):
        if filepath.is_file():
            relative_path = str(filepath.relative_to(target_dir))
            current_hashes[relative_path] = calculate_sha256(filepath)
            
            # 1a. Modification Check
            if relative_path in baseline and current_hashes[relative_path] != baseline[relative_path]:
                incidents["modified"].append({
                    "file": relative_path,
                    "baseline_hash": baseline[relative_path],
                    "current_hash": current_hashes[relative_path]
                })
                
            # 1b. Addition Check
            elif relative_path not in baseline:
                incidents["added"].append({
                    "file": relative_path,
                    "current_hash": current_hashes[relative_path]
                })

    # 2. Deletion Check
    for path_in_baseline in baseline:
        if path_in_baseline not in current_hashes:
            incidents["deleted"].append({
                "file": path_in_baseline,
                "baseline_hash": baseline[path_in_baseline]
            })

    # 3. সামারি প্রিন্ট করা
    total_incidents = sum(len(v) for v in incidents.values())
    if total_incidents == 0:
        print("[SUCCESS] No integrity breaches detected.")
    else:
        print(f"\n[ALERT] Integrity Breaches Detected: {total_incidents} Total!")
        # মডিউল ৪ এর কাজ এখানে হবে (রিপোর্ট তৈরি)
        
    return incidents

# (যদি আপনার import list এ না থাকে, তবে ফাইলের শুরুতে 'import time' যোগ করতে পারেন)

if __name__ == "__main__":
    
    # টার্গেট ফোল্ডার তৈরি করুন (যদি না থাকে, তবে তৈরি করে ডামি ফাইল রাখুন)
    if not TARGET_DIR.exists():
        TARGET_DIR.mkdir()
        # টেস্ট করার জন্য একটি ডামি ফাইল তৈরি করুন
        (TARGET_DIR / "test_config.txt").write_text("This is the initial content.", encoding="utf-8")
        print(f"[SETUP] Created initial test files in {TARGET_DIR}")

    # --- কমান্ড লাইন আর্গুমেন্ট হ্যান্ডেলিং ---
    if len(sys.argv) > 1:
        if sys.argv[1] == '--create-baseline':
            create_baseline(TARGET_DIR)
        
        elif sys.argv[1] == '--monitor': 
            # মনিটর করার জন্য, প্রথমে বেসলাইন লোড করতে হবে
            print("\n[INFO] Starting Monitoring Mode...")
            baseline_data = load_baseline()
            if baseline_data:
                # মনিটরিং শুরু
                incidents = check_integrity(TARGET_DIR, baseline_data)
                # print(f"Incidents: {incidents}") # ডিবাগিং এর জন্য
            
        else:
            # যদি ভুল আর্গুমেন্ট দেওয়া হয়
            print("\nUsage:")
            print("1. Create Baseline: python3 fim_agent.py --create-baseline")
            print("2. Monitor Files:   python3 fim_agent.py --monitor")
    else:
        # যদি কোনো আর্গুমেন্টই না দেওয়া হয়
        print("\nUsage:")
        print("1. Create Baseline: python3 fim_agent.py --create-baseline")
        print("2. Monitor Files:   python3 fim_agent.py --monitor")
